# âš™ï¸ Step 3â€“9: Batch Processing Logic (combined cleanly)
def process_batch(batch_df, batch_id):
    paths = batch_df.select("path").rdd.map(lambda r: r[0]).collect()

    for path in paths:
        try:
            filename = os.path.basename(path)
            ext = os.path.splitext(filename)[1].lower().strip(".")

            # ğŸ·ï¸ Step 4: Routing Rule
            if "edm_entity" in filename.lower():
                table_name = "edm_entity"
            else:
                print(f"âŒ No routing rule for file: {filename}")
                continue

            target_table = f"{org_name}.bronze.{table_name}"
            schema_tracking_path = f"s3://your-bucket/schema-tracking/{org_name}/{schema_name}/{table_name}/"
            checkpoint_path = f"s3://your-bucket/checkpoints/{org_name}/{schema_name}/{table_name}/"
            print(f"ğŸ” Routing file: {filename} â†’ Table: {target_table}")

            # ğŸ“¥ Step 5: Read File
            if ext in ["csv", "txt"]:
                df = spark.read.option("header", "true").option("inferSchema", "true").csv(path)
            elif ext == "json":
                df = spark.read.option("inferSchema", "true").json(path)
            else:
                print(f"âš ï¸ Unsupported format: {filename}")
                continue

            df = df.withColumn("source_file", input_file_name())

            # ğŸ§± Step 6: Validate Table
            if not spark._jsparkSession.catalog().tableExists(target_table):
                print(f"ğŸš« Table not found for {filename}. File remains in landing zone.")
                continue

            # ğŸ’¾ Step 7: Write to Table
            df.write.format("delta").mode("append").saveAsTable(target_table)
            print(f"âœ… Loaded into: {target_table}")

            # ğŸ—ƒï¸ Step 8: Archive the File
            archive_path = path.replace("landing-zone", "archive-zone")
            dbutils.fs.mv(path, archive_path)
            print(f"ğŸ“¦ Archived: {archive_path}")

        except Exception as e:
            # âŒ Step 9: Handle Errors
            print(f"âŒ Error processing {filename}: {e}")
